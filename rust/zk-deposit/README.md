# ZkDeposit

Smart contract that allows users to transfer token assets to other
users using an alternative secret identity, without knowing the user's
blockchain identity.

The contract can be "attached" to any MPC20-compatible token contract, and can
then allow users to [`deposit`] their token balances in the token contract,
such that they are available in ZkDeposit.

## Features

Features:

- Compatible with MPC20 token contract.
- Split identities: Each user has a **blockchain identity** (their
  [`Address`]), and a **recipient identity** (their `recipient_key`.)
  * Both identities are generated by the user.
  * The ZkDeposit MPC should be the only mapping between these identities.
  * Senders can know the recipient identity without knowing the blockchain
    identity.
- Users have hidden balances, such that outsiders and other users cannot
  determine the wealth of individual users.
- Secret transfer functionality allows transfers between parties without
  outsiders observing the recipient and the sent amount.
  * The transfer updates all balances and produces new balances, which prevents
    anybody other than the recipient from knowing the recipient.
  * Transfers are done using the **recipient identity**, which prevents the
    sender from knowing the **blockchain identity** of the recipient.
- User's **blockchain identity** own their deposit balances, and allows them to
  freely read it (by downloading the secret shares). This also allows anybody to
  download the full list of blockchain identities from the contract. It is
  not possible to download the recipient identities of a user.
- Transfers must be approved by a single approver. The approver has the
  responsibility for verifying that transfers are correct, and these transfers
  do not attempt to exploit side-channels.
  * The approver does not need to [`create_account`].
  * The approver cannot use other's balances.
- Uses same deposit/withdraw protocol as [liquidity swap](../liquidity_swap).

## Use cases

The contract opens up a lot of use cases, most notably the _secret transfer_
feature, which can be used to avoid censorship and allows the user true freedom
in how to spend their money, without fear of retribution.

Another use case: Humanitarian aid in areas where walking around with cash
is a surefire way to get robbed. Humanitarian aid NGOs must perform
know-your-customer processes to ensure that users are real and who they claim
to be, but traditional blockchain solutions will often couple this KYC
information directly to the blockchain address of the user, and allows the NGO
(or rogue actors within an NGO) to monitor the transaction activities of the
recipient, whom they know by name and address. By separating the identities, it
is possible to perform KYC on one identity, while allowing users to spend
without surveillance (at least from the NGO.)

## Usage

The basic flows is:

1. Recipients (and sender) register using [`create_account`].
2. Sender [`deposit`] some tokens.
3. Sender requests the creation of transfers of tokens to the recipients, by using [`request_transfer`].
4. The approver can inspect the secret-shared transfer.
5. The approver then [`approve_transfer`], which results in the execution of the transfer.
   - The transfer updates all balances and produces new balances, which prevents
     anybody other than the recipient from knowing the recipient.
6. Recipients can inspect the secret-shared account balance.
7. Recipients can now [`withdraw`] tokens, if they have any.

Account creation:

1. Users create their blockchain identity and their recipient identity.
2. User invokes [`create_account`] with their new recipient identity.
3. Note that account creation must be done before any other action will succeed. This includes both sender and recipient.

Deposit:

1. `token.approve(deposit, amount)`
2. [`deposit`].
   - This action cannot be invoked at all before [`create_account`], to prevent tokens getting stuck in the deposit contract.
   - Transaction: `token.transfer_from(user, deposit, amount)`
   - MPC: Increment user balance by `amount`.

Request transfer:

1. [`request_transfer`]
   - This action cannot be invoked at all before [`create_account`]
   - Results in an unapproved transfer.

Approve Transfer:

1. [`approve_transfer`]
   - MPC: Decrement sender balance by `amount`.
   - MPC: Increment receiver balance by `amount`.

Withdraw:

1. [`withdraw`]
   - This action cannot be invoked at all before [`create_account`]
   - MPC: Decrement user balance by `amount`.
   - Transaction: `token.transfer(deposit, user, amount)`.

Check balance:

1. Check [`ContractState::balances`] for the user address, and find id of secret.
2. Download shares of secret, and reconstruct.

## State

[`ContractState`] contains:

- [`ContractState::balances`]: Mapping from user [`Address`]es to variable id
  of the account balance.
- [`ContractState::work_queue`]: Queue of work items to be done through MPC
- [`ContractState::transfers_yet_to_be_approved`]: List of transfers that
  haven't been approved yet.
- [`ContractState::transfer_approver`]: User that must approve all transfers.

Secret variables:

- [`VariableKind::DepositBalance`]: Owner is public. Balance is secret,
  along with the `deposit_key`. The deposit key is used to transfer tokens to
  the balance.

## Invariants

Contract invariants:

- Sum of all deposits in `deposit` should be equal to `deposit`'s balance in
  `token`. Note that this can be violated if a user transfers tokens directly
  to the contract.
- Contract should not own any secrets, and will transfer ownership of secrets
  to the owner ASAP.
- All balance secrets must be directly referenced from the
  [`ContractState::balances`] map. Balance secrets not in the map should be
  removed.
- When contract is idle (queue is empty, and no computation active):
  * Amount of [`VariableKind::DepositBalance`] secrets equal to size of
    [`ContractState::balances`]
  * [`ContractState::redundant_variables`] is empty.

## Performance

- [`create_account`] involves MPC: Linear time with respect to the total number
  of users. Must iterate over all balances to determine whether the recipient
  id already has a balance. Produces a single new balance.
- [`deposit`] involves MPC: Constant time. Only need to update the depositing
  user's balance.
- [`withdraw`] involves MPC: Constant time. Only need to update the withdrawing
  user's balance.
- [`request_transfer`] does not involve MPC.
- [`approve_transfer`] involves MPC: Linear time with respect to the total
  number of users. Must iterate over all balances to find the recipient
  balance, and to update all balances. Produces a complete set of new balances.

## Side-channel attacks

There are some side-channel attacks on the `zk-deposit`, that allows the sender
to collate the recipient's recipient ID and their blockchain ID. The approver
is supposed to prevent these attacks by verifying that any given transfer does
not reveal information.

Attack vectors:

- High entropy transfer amounts: An attacker can send unique token amounts to
  each recipient, with the assumption that the recipient withdraws as much as
  possible at each opportunity.
- Timing attacks: An attacker sends tokens to individual keys one at a time. If
  the recipient is the only user with a balance, it becomes trivial to identity
  them when they withdraw money.
- Differential analysis: An attacker sends tokens in rounds to overlapping
  groups of users. The overlap is a single user, whom can be easily identified,
  because they are the only user to receive and withdraw for both rounds.

Effective mitigations:

- Transfer to a large subset of recipients at the same time (possibly all)
- Transfer the same amount to each recipient.
- If transferring to groups of recipients at a time, care must be taken to
  maintain the same groups over time.

## Alternatives

This is one of several possible secret transfer contracts, and its
transfer operation is of the slower variety.

Consider the possible attributes that can be secret:

- `sender`: Who is sending this transfer?
- `recipient`: Who is receiving this transfer?
- `amount`: Amount of tokens sent.
- `balance`: User's balances.
- `balance` (existence): Which users have a balance.
- transfer success: Whether any given transfer succeeded or not, and thus
  whether the user had enough tokens to transfer the amount.

Note that there are some obvious dependencies between these:

- `amount` and `balance` must be secret together. Having one public makes it
  trivial to determine the other.
- `recipient`: Requires `amount` secret.
- `Sender`: Requires `recipient`. (it is possible to flip them, and might be
  interesting in certain threat models, but not this one.)
- `balance` (exist): Requires at least `balance` and `recipient`.

This results in the following list of possible transfer implementations:

| Name                          | Performance | Sender  | Recipient | Amount | Balance | Balance exists? |
| ----                          | ---         | ----    | --        | ------ | ------- | --------------- |
| [`token-v2`](../token-v2)     | Good        | Public  | Public    | Public | Public  | Public          |
| `zk-token`                    | Good        | Public  | Public    | Secret | Secret  | Public          |
| [`zk-deposit`](../zk-deposit) (this contract) | Poor        | Public  | Secret    | Secret | Secret  | Public          |
| Very Secret                   | Bad         | Secret  | Secret    | Secret | Secret  | Public          |
| Impractical Top Secret        | Very Bad    | Secret  | Secret    | Secret | Secret  | Secret          |

If _balance exist_ is secret, it becomes complicated for the user/client
to determine the user's balance.
